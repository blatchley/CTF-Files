import math

def getModInverse(a, m):
    if math.gcd(a, m) != 1:
        return None
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m

    while v3 != 0:
        q = u3 // v3
        v1, v2, v3, u1, u2, u3 = (
            u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m

def main():
    p = 139273738791783159723474135450706076467688313217878303266725869679643941089782519599883739126996219650621388485987414991867541011100943309302393720470007767213704282638154239527901442275072985464612168000425163572105027092370553317488531002704964446770559239652475542801615277593462962102824810226264704834429
    q = 139273738791783159723474135450706076467688313217878303266725869679643941089782519599883739126996219650621388485987414991867541011100943309302393720470007767213704282638154239527901442275072985464612168000425163572105027092370553317488531002704964446770559239652475542801615277593462962102824810226264704766731
    e = 65537
    ct = 4924073586821671527949698583847203147600620011362322709797522548555428980319945799413779923551665316951930902764942377192497415322527876266936089487517956609319890842634501593715977123043465288381947540770199166848391804079098765928847217117762382416341477852908231615390548080268681347015867083228952721218066914089723946495203121391193144850581550729236964401041171591573672335602395020684213731711127776739483727654127919583206391470399978731316763748140389367180057717870243190132716227407749426940074848366700008056333429029807743343589243272332397016837931973815118043893291388933792755616024260088620618145143

    # compute n
    n = p * q

    # Compute phi(n)
    phi = (p - 1) * (q - 1)

    # Compute modular inverse of e
    d = getModInverse(e, phi)

    print("n:  " + str(d))

    # Decrypt ciphertext
    pt = pow(ct, d, n)
    print("pt: " + str(pt))

if __name__ == "__main__":
    main()